https://www.cnblogs.com/panxuejun/p/9054080.html

共享锁【S锁】
又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。
这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

排他锁【X锁】
又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。
这保证了其他事务在T释放A上的锁之前不能再读取和修改A。

共享锁与排它锁区别
1.共享锁只用于表级，排他锁用于行级。 共享锁保证了其他事务不能写，排他锁保证了其他事物不能读。

共享锁保证了其他事务不能写，排他锁保证了其他事物不能读。
2.加了共享锁的对象，可以继续加共享锁，不能再加排他锁。加了排他锁后，不能再加任何锁。
3.比如一个DML操作，就要对受影响的行加排他锁，这样就不允许再加别的锁，也就是说别的会话不能修改这些行。同时为了避免在做这个DML操作的时候，有别的会话执行DDL，修改表的定义，所以要在表上加共享锁，这样就阻止了DDL的操作。
4.当执行DDL操作时，就需要在全表上加排他锁

mysql共享锁与排他锁
mysql锁机制分为表级锁和行级锁，本文就和大家分享一下我对mysql中行级锁中的共享锁与排他锁进行分享交流。
共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。
排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。
对于共享锁大家可能很好理解，就是多个事务只能读数据不能改数据，对于排他锁大家的理解可能就有些差别，我当初就犯了一个错误，以为排他锁锁住一行数据后，其他事务就不能读取和修改该行数据，其实不是这样的。
排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。mysql InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型，如果加排他锁可以使用select ...for update语句，加共享锁可以使用select ... lock in share mode语句。
所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select ...from...查询数据，因为普通查询没有任何锁机制。

重点：
select语句默认不会加任何锁类型，如果加排他锁可以使用select ...for update语句，加共享锁可以使用select ... lock in share mode语句。所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select ...from...查询数据，因为普通查询没有任何锁机制。

select不加锁，
update,delete,insert都会自动给涉及到的数据加上排他锁
加上排它锁的数据依然可以被不加锁的查询方法查询到数据。

乐观锁：
锁设计的一种模式，一般觉得数据的不会被修改。适用于多读少写的情况。
读取时不加锁，写入时判断version。
基于数据库时则是读取时不加锁，更新时，由于数据库的机制，自动加了排他锁


悲观锁：
锁设计的一种模式，一般觉得数据的一定会被修改。适用于少读多写的情况。
数据库中的行锁，表锁，读锁，写锁，以及 syncronized 实现的锁均为悲观锁。
读取时就加锁，写入完成之后才释放锁。
基于数据库则是读取时就加了排它锁，在加上事务性，所以确保数据一定不会出错。
